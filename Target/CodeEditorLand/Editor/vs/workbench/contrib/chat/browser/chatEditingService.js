var H=Object.defineProperty;var X=Object.getOwnPropertyDescriptor;var v=(u,s,e,t)=>{for(var i=t>1?void 0:t?X(s,e):s,r=u.length-1,n;r>=0;r--)(n=u[r])&&(i=(t?n(s,e,i):n(i))||i);return t&&i&&H(s,e,i),i},a=(u,s)=>(e,t)=>s(e,t,u);import{Sequencer as Y}from"../../../../base/common/async.js";import{CancellationTokenSource as Z}from"../../../../base/common/cancellation.js";import{Codicon as A}from"../../../../base/common/codicons.js";import{BugIndicatingError as D}from"../../../../base/common/errors.js";import{Emitter as F}from"../../../../base/common/event.js";import{Disposable as L,DisposableStore as ee,MutableDisposable as ie}from"../../../../base/common/lifecycle.js";import{derived as te,observableValue as b,ValueWithChangeEventFromObservable as se}from"../../../../base/common/observable.js";import{URI as I}from"../../../../base/common/uri.js";import{IBulkEditService as j}from"../../../../editor/browser/services/bulkEditService.js";import"../../../../editor/common/languages.js";import{ILanguageService as re}from"../../../../editor/common/languages/language.js";import"../../../../editor/common/model.js";import{createTextBufferFactoryFromSnapshot as ne}from"../../../../editor/common/model/textModel.js";import{IModelService as $}from"../../../../editor/common/services/model.js";import{ITextModelService as J}from"../../../../editor/common/services/resolverService.js";import{localize as w,localize2 as x}from"../../../../nls.js";import{Action2 as E,MenuId as S,registerAction2 as y}from"../../../../platform/actions/common/actions.js";import{ContextKeyExpr as g,IContextKeyService as oe,RawContextKey as G}from"../../../../platform/contextkey/common/contextkey.js";import{EditorActivation as C}from"../../../../platform/editor/common/editor.js";import{IInstantiationService as q}from"../../../../platform/instantiation/common/instantiation.js";import{bindContextKey as ae}from"../../../../platform/observable/common/platformObservableUtils.js";import{IProgressService as de,ProgressLocation as ce}from"../../../../platform/progress/common/progress.js";import{DiffEditorInput as le}from"../../../common/editor/diffEditorInput.js";import"../../../common/editor/editorInput.js";import{IEditorGroupsService as z}from"../../../services/editor/common/editorGroupsService.js";import{IEditorService as Q}from"../../../services/editor/common/editorService.js";import"../../multiDiffEditor/browser/multiDiffEditor.js";import{MultiDiffEditorInput as N}from"../../multiDiffEditor/browser/multiDiffEditorInput.js";import{IMultiDiffSourceResolverService as ue,MultiDiffEditorItem as pe}from"../../multiDiffEditor/browser/multiDiffSourceResolverService.js";import{ICodeMapperService as he}from"../common/chatCodeMapperService.js";import{ChatEditingSessionState as p,IChatEditingService as _,ModifiedFileEntryState as m}from"../common/chatEditingService.js";import"../common/chatModel.js";import{IChatService as fe}from"../common/chatService.js";import{IChatWidgetService as W}from"./chat.js";const V=new G("decidedChatEditingResource",[]),B=new G("chatEditingResource",void 0),ge=new G("inChatEditingSession",void 0);let T=class extends L{constructor(e,t,i,r,n,o,c,R){super();this._editorGroupsService=e;this._instantiationService=t;this._chatService=o;this._progressService=c;this._codeMapperService=R;this._register(i.registerResolver(t.createInstance(d,this._currentSessionObs))),r.registerTextModelContentProvider(l.scheme,t.createInstance(l,this._currentSessionObs)),this._register(ae(V,n,f=>{const K=this._currentSessionObs.read(f);return K?K.entries.read(f).filter(k=>k.state.read(f)!==m.Undecided).map(k=>k.entryId):void 0})),this._register(this._chatService.onDidDisposeSession(f=>{f.reason==="cleared"&&this._currentSessionObs.get()?.chatSessionId===f.sessionId&&this._currentSessionObs.get()?.stop()}))}_serviceBrand;_currentSessionObs=b(this,null);_currentSessionDisposeListener=this._register(new ie);get currentEditingSession(){return this._currentSessionObs.get()}_onDidCreateEditingSession=new F;get onDidCreateEditingSession(){return this._onDidCreateEditingSession.event}async addFileToWorkingSet(e){const t=this._currentSessionObs.get();t&&t.addFileToWorkingSet(e)}dispose(){this._currentSessionObs.get()?.dispose(),super.dispose()}async startOrContinueEditingSession(e,t){const i=this._currentSessionObs.get();if(i&&i.chatSessionId!==e)throw new D("Cannot start new session while another session is active");return this._createEditingSession(e,t)}async _createEditingSession(e,t){if(this._currentSessionObs.get())throw new D("Cannot have more than one active editing session");this._register(this.installAutoApplyObserver(e));const i=N.fromResourceMultiDiffEditorInput({multiDiffSource:d.getMultiDiffSourceUri(),label:w("multiDiffEditorInput.name","Suggested Edits")},this._instantiationService),r=t?.silent?void 0:await this._editorGroupsService.activeGroup.openEditor(i,{pinned:!0,activation:C.ACTIVATE}),n=this._instantiationService.createInstance(M,e,r);return this._currentSessionDisposeListener.value=n.onDidDispose(()=>{this._currentSessionDisposeListener.clear(),this._currentSessionObs.set(null,void 0)}),this._currentSessionObs.set(n,void 0),this._onDidCreateEditingSession.fire(n),n}triggerEditComputation(e){return this._continueEditingSession(async(t,i)=>{const r={textEdit:(n,o)=>t.textEdits(n,o)};await this._codeMapperService.mapCodeFromResponse(e,r,i)},{silent:!0})}installAutoApplyObserver(e){const t=this._chatService.getSession(e);if(!t)throw new Error(`Edit session was created for a non-existing chat session: ${e}`);const i=new ee,r=n=>{n.result?.metadata?.autoApplyEdits&&this.triggerEditComputation(n)};return i.add(t.onDidChange(n=>{if(n.kind==="addRequest"){const o=n.request.response;if(o)if(o.isComplete)r(o);else{const c=o.onDidChange(()=>{o.isComplete?(r(o),c.dispose()):(o.isCanceled||o.isStale)&&c.dispose()})}}})),i.add(t.onDidDispose(()=>i.dispose())),i}async _continueEditingSession(e,t){const i=this._currentSessionObs.get();if(!i)throw new D("Cannot continue missing session");if(i.state.get()===p.StreamingEdits)throw new D("Cannot continue session that is still streaming");let r;if(!t?.silent&&i.isVisible){const c=this._findGroupedEditors();if(c.length!==1)throw new Error(`Unexpected number of editors: ${c.length}`);const[R,f]=c[0];r=await R.openEditor(f,{pinned:!0,activation:C.ACTIVATE})}const n={textEdits:(c,R)=>{i.acceptTextEdits(c,R)}};i.acceptStreamingEditsStart();const o=new Z;try{r?await r?.showWhile(e(n,o.token)):await this._progressService.withProgress({location:ce.Window,title:x("chatEditing.startingSession","Generating edits...").value},async()=>{await e(n,o.token)},()=>o.cancel())}finally{o.dispose(),i.resolve()}}_findGroupedEditors(){const e=[];for(const t of this._editorGroupsService.groups)for(const i of t.editors)i.resource?.scheme===d.scheme&&e.push([t,i]);return e}};T=v([a(0,z),a(1,q),a(2,ue),a(3,J),a(4,oe),a(5,fe),a(6,de),a(7,he)],T);let d=class{constructor(s,e){this._currentSession=s;this._instantiationService=e}static scheme="chat-editing-multi-diff-source";static getMultiDiffSourceUri(){return I.from({scheme:d.scheme,path:""})}canHandleUri(s){return s.scheme===d.scheme}async resolveDiffSource(s){return this._instantiationService.createInstance(Se,this._currentSession)}};d=v([a(1,q)],d);class Se{constructor(s){this._currentSession=s}_resources=te(this,s=>{const e=this._currentSession.read(s);return e?e.entries.read(s).map(i=>new pe(i.originalURI,i.modifiedURI,void 0,{[B.key]:i.entryId})):[]});resources=new se(this._resources);contextKeys={[ge.key]:!0}}y(class extends E{constructor(){super({id:"chatEditing.openFile",title:x("open.file","Open File"),icon:A.goToFile,menu:[{id:S.ChatEditingSessionWidgetToolbar,order:0,group:"navigation"}]})}async run(s,...e){const t=s.get(_),i=s.get(Q);if(!t.currentEditingSession)return;const n=s.get(W).lastFocusedWidget,o=[];I.isUri(e[0])?o.push(e[0]):n&&o.push(...n.input.selectedElements),o.length&&await Promise.all(o.map(c=>i.openEditor({resource:c,options:{pinned:!0,activation:C.ACTIVATE}})))}}),y(class extends E{constructor(){super({id:"chatEditing.acceptFile",title:x("accept.file","Accept"),icon:A.check,menu:[{when:g.and(g.equals("resourceScheme",d.scheme),g.notIn(B.key,V.key)),id:S.MultiDiffEditorFileToolbar,order:0,group:"navigation"},{id:S.ChatEditingSessionWidgetToolbar,order:2,group:"navigation"}]})}async run(s,...e){const i=s.get(_).currentEditingSession;if(!i)return;const r=s.get(W).lastFocusedWidget,n=[];I.isUri(e[0])?n.push(e[0]):r&&n.push(...r.input.selectedElements),n.length&&await i.accept(...n)}}),y(class extends E{constructor(){super({id:"chatEditing.discardFile",title:x("discard.file","Discard"),icon:A.discard,menu:[{when:g.and(g.equals("resourceScheme",d.scheme),g.notIn(B.key,V.key)),id:S.MultiDiffEditorFileToolbar,order:0,group:"navigation"},{id:S.ChatEditingSessionWidgetToolbar,order:1,group:"navigation"}]})}async run(s,...e){const i=s.get(_).currentEditingSession;if(!i)return;const r=s.get(W).lastFocusedWidget,n=[];I.isUri(e[0])?n.push(e[0]):r&&n.push(...r.input.selectedElements),n.length&&await i.reject(...n)}});class U extends E{static ID="chatEditing.acceptAllFiles";static LABEL=w("accept.allFiles","Accept All");constructor(){super({id:U.ID,title:U.LABEL,menu:{when:g.equals("resourceScheme",d.scheme),id:S.EditorTitle,order:0,group:"navigation"}})}async run(s,...e){const i=s.get(_).currentEditingSession;i&&await i.accept()}}y(U);class O extends E{static ID="chatEditing.discardAllFiles";static LABEL=w("discard.allFiles","Discard All");constructor(){super({id:O.ID,title:O.LABEL,menu:{when:g.equals("resourceScheme",d.scheme),id:S.EditorTitle,order:0,group:"navigation"}})}async run(s,...e){const i=s.get(_).currentEditingSession;i&&await i.reject()}}y(O);class P extends E{static ID="chatEditing.openDiffs";static LABEL=w("chatEditing.openDiffs","Open Diffs");constructor(){super({id:P.ID,title:P.LABEL,f1:!1})}async run(s,...e){const i=s.get(_).currentEditingSession;i&&await i.show()}}y(P);let l=class{constructor(s,e){this._currentSessionObs=s;this._modelService=e}static scheme="chat-editing-text-model";static getEmptyFileURI(){return I.from({scheme:l.scheme,query:JSON.stringify({kind:"empty"})})}static getFileURI(s,e){return I.from({scheme:l.scheme,path:e,query:JSON.stringify({kind:"doc",documentId:s})})}async provideTextContent(s){const e=this._modelService.getModel(s);if(e&&!e.isDisposed())return e;const t=JSON.parse(s.query);if(t.kind==="empty")return this._modelService.createModel("",null,s,!1);const i=this._currentSessionObs.get();return i?i.getVirtualModel(t.documentId):null}};l=v([a(1,$)],l);let M=class extends L{constructor(e,t,i,r,n,o,c){super();this.chatSessionId=e;this.editorPane=t;this._instantiationService=i;this._textModelService=r;this._bulkEditService=n;this._editorGroupsService=o;this.editorService=c}_state=b(this,p.Initial);_entriesObs=b(this,[]);get entries(){return this._assertNotDisposed(),this._entriesObs}_sequencer=new Y;_entries=[];_workingSetObs=b(this,[]);_workingSet=[];get workingSet(){return this._assertNotDisposed(),this._workingSetObs}get state(){return this._assertNotDisposed(),this._state}_onDidChange=new F;get onDidChange(){return this._assertNotDisposed(),this._onDidChange.event}_onDidDispose=new F;get onDidDispose(){return this._assertNotDisposed(),this._onDidDispose.event}get isVisible(){return this._assertNotDisposed(),!!(this.editorPane&&this.editorPane.isVisible())}_assertNotDisposed(){if(this._state.get()===p.Disposed)throw new D("Cannot access a disposed editing session")}async accept(...e){this._assertNotDisposed(),e.length===0&&await Promise.all(this._entries.map(t=>t.accept(void 0)));for(const t of e){const i=this._entries.find(r=>r.modifiedURI.toString()===t.toString());i&&await i.accept(void 0)}this._onDidChange.fire()}async reject(...e){this._assertNotDisposed(),e.length===0&&await Promise.all(this._entries.map(t=>t.reject(void 0)));for(const t of e){const i=this._entries.find(r=>r.modifiedURI.toString()===t.toString());i&&await i.reject(void 0)}this._onDidChange.fire()}async show(){if(this._assertNotDisposed(),this.editorPane?.isVisible())return;if(this.editorPane?.input){await this._editorGroupsService.activeGroup.openEditor(this.editorPane.input,{pinned:!0,activation:C.ACTIVATE});return}const e=N.fromResourceMultiDiffEditorInput({multiDiffSource:d.getMultiDiffSourceUri(),label:w("multiDiffEditorInput.name","Suggested Edits")},this._instantiationService),t=await this._editorGroupsService.activeGroup.openEditor(e,{pinned:!0,activation:C.ACTIVATE});this.editorPane=t}async stop(){this._assertNotDisposed(),await Promise.allSettled(this._editorGroupsService.groups.map(async e=>Promise.allSettled(e.editors.map(async t=>{(t instanceof N||t instanceof le&&(t.original.resource?.scheme===h.scheme||t.original.resource?.scheme===l.scheme))&&await e.closeEditor(t)})))),this._state.get()!==p.Disposed&&this.dispose()}dispose(){this._assertNotDisposed(),super.dispose(),this._state.set(p.Disposed,void 0),this._onDidDispose.fire()}getVirtualModel(e){return this._assertNotDisposed(),this._entries.find(i=>i.entryId===e)?.docSnapshot??null}acceptStreamingEditsStart(){this._state.get()!==p.Disposed&&this._sequencer.queue(()=>this._acceptStreamingEditsStart())}acceptTextEdits(e,t){this._state.get()!==p.Disposed&&this._sequencer.queue(()=>this._acceptTextEdits(e,t))}resolve(){this._state.get()!==p.Disposed&&this._sequencer.queue(()=>this._resolve())}addFileToWorkingSet(e){this._workingSet=[...this._workingSet,e],this._workingSetObs.set(this._workingSet,void 0),this._onDidChange.fire()}async _acceptStreamingEditsStart(){this._state.set(p.StreamingEdits,void 0),this._onDidChange.fire()}async _acceptTextEdits(e,t){const i=await this._getOrCreateModifiedFileEntry(e);i.applyEdits(t),await this.editorService.openEditor({original:{resource:i.originalURI},modified:{resource:i.modifiedURI},options:{inactive:!0}})}async _resolve(){this._state.set(p.Idle,void 0),this._onDidChange.fire()}async _getOrCreateModifiedFileEntry(e){const t=this._entries.find(r=>r.resource.toString()===e.toString());if(t)return t;const i=await this._createModifiedFileEntry(e);return this._register(i),this._entries=[...this._entries,i],this._entriesObs.set(this._entries,void 0),this._onDidChange.fire(),i}async _createModifiedFileEntry(e,t=!1){try{const i=await this._textModelService.createModelReference(e);return this._instantiationService.createInstance(h,e,i,{collapse:r=>this._collapse(e,r)})}catch(i){if(t)throw i;return await this._bulkEditService.apply({edits:[{newResource:e}]}),this._createModifiedFileEntry(e,!0)}}_collapse(e,t){const i=this.editorPane?.findDocumentDiffItem(e);i&&this.editorPane?.viewModel?.items.get().find(r=>String(r.originalUri)===String(i.originalUri)&&String(r.modifiedUri)===String(i.modifiedUri))?.collapsed.set(!0,t)}};M=v([a(2,q),a(3,J),a(4,j),a(5,z),a(6,Q)],M);let h=class extends L{constructor(e,t,i,r,n,o){super();this.resource=e;this._multiDiffEntryDelegate=i;this._bulkEditService=o;this.doc=t.object.textEditorModel,this.docSnapshot=this._register(r.createModel(ne(this.doc.createSnapshot()),n.createById(this.doc.getLanguageId()),l.getFileURI(this.entryId,e.path),!1)),this._register(t)}static scheme="modified-file-entry";static lastEntryId=0;entryId=`${h.scheme}::${++h.lastEntryId}`;docSnapshot;doc;get originalURI(){return this.docSnapshot.uri}get modifiedURI(){return this.doc.uri}_stateObs=b(this,m.Undecided);get state(){return this._stateObs}applyEdits(e){this.doc.applyEdits(e),this._stateObs.set(m.Undecided,void 0)}async accept(e){this._stateObs.get()===m.Undecided&&(this.docSnapshot.setValue(this.doc.createSnapshot()),this._stateObs.set(m.Accepted,e),await this.collapse(e))}async reject(e){this._stateObs.get()===m.Undecided&&(this.doc.setValue(this.docSnapshot.createSnapshot()),this._stateObs.set(m.Rejected,e),await this.collapse(e))}async collapse(e){this._multiDiffEntryDelegate.collapse(e)}};h=v([a(3,$),a(4,re),a(5,j)],h);export{U as ChatEditingAcceptAllAction,O as ChatEditingDiscardAllAction,T as ChatEditingService,P as ChatEditingShowChangesAction};
